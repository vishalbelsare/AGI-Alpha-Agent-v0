# SPDX-License-Identifier: Apache-2.0
"""Verify gRPC delivery with certificates generated by gen_bus_certs.sh."""

from __future__ import annotations

import asyncio
import json
import socket
import subprocess
import shutil
from pathlib import Path

import grpc
import pytest
from alpha_factory_v1.common.utils import config, messaging


def _free_port() -> int:
    s = socket.socket()
    s.bind(("localhost", 0))
    port = s.getsockname()[1]
    s.close()
    return port


def _gen_certs(tmp: Path) -> tuple[str, str, bytes, str]:
    root = Path(__file__).resolve().parents[1]
    script = root / "infrastructure" / "gen_bus_certs.sh"
    subprocess.run(["bash", str(script)], cwd=tmp, check=True, capture_output=True)
    cert = tmp / "certs" / "bus.crt"
    key = tmp / "certs" / "bus.key"
    token = "tok"
    ca = cert.read_bytes()
    return str(cert), str(key), ca, token


def test_bus_secure(tmp_path: Path) -> None:
    port = _free_port()
    cert, key, ca, token = _gen_certs(tmp_path)
    cfg = config.Settings(
        bus_port=port,
        bus_cert=cert,
        bus_key=key,
        bus_token=token,
        allow_insecure=False,
    )
    received: list[messaging.Envelope] = []

    async def run() -> None:
        async with messaging.A2ABus(cfg) as bus:
            bus.subscribe("b", lambda e: received.append(e))
            creds = grpc.ssl_channel_credentials(root_certificates=ca)
            async with grpc.aio.secure_channel(f"localhost:{port}", creds) as ch:
                stub = ch.unary_unary("/bus.Bus/Send")
                await stub(f"{messaging.A2ABus.PROTO_VERSION} n1".encode())
                payload = {
                    "sender": "a",
                    "recipient": "b",
                    "payload": {"v": 1},
                    "ts": 0.0,
                    "token": token,
                }
                await stub(json.dumps(payload).encode())
            await asyncio.sleep(0.05)

            # second connection with invalid token should be rejected
            async with grpc.aio.secure_channel(f"localhost:{port}", creds) as ch:
                stub = ch.unary_unary("/bus.Bus/Send")
                await stub(f"{messaging.A2ABus.PROTO_VERSION} n2".encode())
                payload["token"] = "bad"
                with pytest.raises(grpc.aio.AioRpcError) as excinfo:
                    await stub(json.dumps(payload).encode())
                assert excinfo.value.code() == grpc.StatusCode.PERMISSION_DENIED
            await asyncio.sleep(0.05)

            # replayed handshake should be rejected
            async with grpc.aio.secure_channel(f"localhost:{port}", creds) as ch:
                stub = ch.unary_unary("/bus.Bus/Send")
                with pytest.raises(grpc.aio.AioRpcError):
                    await stub(f"{messaging.A2ABus.PROTO_VERSION} n1".encode())
            await asyncio.sleep(0.05)

            # after the cache TTL the same nonce should still be rejected
            await asyncio.sleep(messaging.A2ABus.HANDSHAKE_TTL + 0.1)
            async with grpc.aio.secure_channel(f"localhost:{port}", creds) as ch:
                stub = ch.unary_unary("/bus.Bus/Send")
                with pytest.raises(grpc.aio.AioRpcError) as excinfo:
                    await stub(f"{messaging.A2ABus.PROTO_VERSION} n1".encode())
                assert excinfo.value.code() == grpc.StatusCode.PERMISSION_DENIED
            await asyncio.sleep(0.05)
        shutil.rmtree(tmp_path / "certs", ignore_errors=True)

    asyncio.run(run())
    assert len(received) == 1 and received[0].payload["v"] == 1


def test_default_token_rejected(tmp_path: Path) -> None:
    """Using the default token should fail when TLS is enabled."""
    port = _free_port()
    cert, key, _ca, _ = _gen_certs(tmp_path)
    with pytest.raises(ValueError):
        config.Settings(bus_port=port, bus_cert=cert, bus_key=key, bus_token="change_this_token")
