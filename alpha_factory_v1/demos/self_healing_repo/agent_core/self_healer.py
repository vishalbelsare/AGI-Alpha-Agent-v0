# SPDX-License-Identifier: Apache-2.0
# self_healer.py
"""Automated test fixing workflow for the self-healing demo."""
from .diff_utils import parse_and_validate_diff
from .llm_client import (
    build_prompt,
    generate_branch_name,
    request_patch,
    summarize_error,
)
from . import sandbox, test_runner

from .. import patcher_core
import logging
import os
import shutil
import subprocess
import tempfile

logger = logging.getLogger(__name__)


class SelfHealer:
    """Manage the self-healing workflow for failing tests.

    This class clones the target repository at a specific commit, executes the
    tests in an isolated environment, and sends any failures to an LLM for
    analysis and patch generation. If the generated patch resolves the failure,
    the fix is committed to a new branch and a pull request is opened.

    Args:
        repo_url: URL of the repository to clone.
        commit_sha: Commit hash that produced the failing tests.
        base_branch: Branch used as the PR base, defaults to ``"main"``.
    """

    def __init__(self, repo_url: str, commit_sha: str, base_branch: str = "main"):
        self.repo_url = repo_url
        self.commit_sha = commit_sha
        self.base_branch = base_branch
        self.working_dir = "/tmp/self_heal_run"  # ephemeral work dir
        self.test_results = None
        self.error_log = None
        self.patch_diff = None

    def setup_repo(self):
        """Clone the repo at the specific commit into a clean working directory."""
        if os.path.exists(self.working_dir):
            shutil.rmtree(self.working_dir)
        os.makedirs(self.working_dir, exist_ok=True)
        subprocess.run(["git", "clone", "--no-checkout", self.repo_url, "."], cwd=self.working_dir, check=True)
        subprocess.run(["git", "checkout", self.commit_sha], cwd=self.working_dir, check=True)
        # Optionally, install dependencies if needed (pip install, etc).
        # This could be inferred from requirements.txt or other config.

    def run_tests_collect_error(self):
        """Run the test suite and collect output if failures occur."""
        runner = test_runner.get_default_runner(self.working_dir)
        rc, output = sandbox.run_in_docker(
            [
                "pytest",
                "-q",
                "--color=no",
            ],
            self.working_dir,
        )
        self.test_results = output
        if rc == 0:
            return True
        self.error_log = runner.extract_failure_log(output)
        return False

    def analyze_and_propose_fix(self):
        """Analyze error_log and get an LLM-proposed diff."""
        if not self.error_log:
            raise RuntimeError("No error log to analyze")
        # Prepare prompt for LLM â€“ include error message and relevant code context
        prompt = build_prompt(self.error_log, code_dir=self.working_dir)
        # Request a diff from LLM
        diff_response = request_patch(prompt)
        # Validate that response is a unified diff
        self.patch_diff = parse_and_validate_diff(diff_response, repo_dir=self.working_dir)
        return self.patch_diff is not None

    def apply_patch(self):
        """Apply the proposed diff to the working directory."""
        if not self.patch_diff:
            raise RuntimeError("No patch to apply")
        try:
            patcher_core.apply_patch(self.patch_diff, repo_path=self.working_dir)
        except Exception as exc:
            logger.error("Failed to apply patch: %s", exc)
            return False
        return True

    def commit_and_push_fix(self):
        """Commit the changes to a new branch and push to remote."""
        branch_name = f"auto-fix/{generate_branch_name(self.error_log)}"
        subprocess.run(["git", "checkout", "-B", branch_name], cwd=self.working_dir, check=True)
        subprocess.run(["git", "add", "."], cwd=self.working_dir, check=True)
        commit_msg = f"Auto-fix: {summarize_error(self.error_log)} [ci skip]"
        subprocess.run(["git", "commit", "-m", commit_msg], cwd=self.working_dir, check=True)
        # Use provided token for auth (set in env for git)
        subprocess.run(["git", "push", "origin", branch_name], cwd=self.working_dir, check=True)
        return branch_name

    def create_pull_request(self, branch_name: str):
        """Open a GitHub Pull Request for the new branch."""
        repo_owner = os.getenv("GITHUB_REPOSITORY_OWNER")  # e.g. from env in CI
        repo_name = os.getenv("GITHUB_REPOSITORY_NAME")
        gh_token = os.getenv("GITHUB_TOKEN")
        title = f"[Self-Heal] Fix for failing test: {summarize_error(self.error_log)}"
        body = "This PR was automatically generated by the self-healing CI agent.\n"
        body += f"Failed Run: commit {self.commit_sha}\n"
        body += "Error Log:\n```\n" + (self.error_log[:500] or "") + "\n```\n"  # include snippet
        body += "\nProposed Fix Diff:\n```diff\n" + (self.patch_diff[:300] or "") + "\n```\n"
        body += "\nPlease review the changes. If approved, this will close the failing issue."
        # Use GitHub API to create PR
        import af_requests as requests

        url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/pulls"
        headers = {"Authorization": f"Bearer {gh_token}"}
        json_data = {"title": title, "head": branch_name, "base": self.base_branch, "body": body}
        response = requests.post(url, headers=headers, json=json_data)
        response.raise_for_status()
        pr_number = response.json().get("number")
        return pr_number

    def run(self):
        """Execute the full self-healing pipeline."""
        self.setup_repo()
        if self.run_tests_collect_error():
            logger.info("No failure detected, nothing to fix.")
            return None
        logger.info("Test failed, error log captured. Analyzing...")
        self.analyze_and_propose_fix()
        if not self.patch_diff:
            logger.warning("LLM did not return a valid patch. Aborting auto-fix.")
            return None
        logger.info("Patch received. Applying patch...")
        if not self.apply_patch():
            logger.error("Failed to apply patch. Aborting.")
            return None
        logger.info("Patch applied. Re-running tests for verification...")
        if not self.run_tests_collect_error():
            # If still failing after patch, we could iterate or abort.
            logger.warning("Patch did not fix the issue. Consider manual intervention.")
            # (Optional) Could attempt another LLM iteration here.
            return None
        logger.info("Tests passed after patch! Preparing to commit and push fix...")
        branch = self.commit_and_push_fix()
        pr = self.create_pull_request(branch)
        logger.info("Opened Pull Request #%s for the fix.", pr)
        return pr
